import Foundation

// MARK: - AI Provider Types

/// Available AI service providers
public enum AIProvider: String, Codable, CaseIterable {
    case appleIntelligence = "apple_intelligence"
    case openAI = "openai"
    case anthropic = "anthropic"
    case offline = "offline"

    public var displayName: String {
        switch self {
        case .appleIntelligence: return "Apple Intelligence"
        case .openAI: return "OpenAI"
        case .anthropic: return "Anthropic"
        case .offline: return "Offline"
        }
    }

    public var requiresAPIKey: Bool {
        switch self {
        case .appleIntelligence, .offline: return false
        case .openAI, .anthropic: return true
        }
    }
}

// MARK: - AI Request/Response Types

/// A question generated by AI
public struct AIGeneratedQuestion: Codable {
    public let question: String
    public let options: [String]      // 4 choices for MC
    public let correctIndex: Int
    public let explanation: String
    public let difficulty: Int         // 1-5
    public let subject: String
    public let gradeLevel: Int         // K=0, 1st=1, ... 8th=8

    public init(question: String, options: [String], correctIndex: Int, explanation: String,
                difficulty: Int, subject: String, gradeLevel: Int) {
        self.question = question
        self.options = options
        self.correctIndex = correctIndex
        self.explanation = explanation
        self.difficulty = difficulty
        self.subject = subject
        self.gradeLevel = gradeLevel
    }
}

/// Result of AI grading a student answer
public struct AIGradingResult: Codable {
    public let score: Int              // 0-100
    public let isCorrect: Bool
    public let feedback: String        // Encouraging feedback in buddy voice
    public let explanation: String     // Why the answer is right/wrong

    public init(score: Int, isCorrect: Bool, feedback: String, explanation: String) {
        self.score = score
        self.isCorrect = isCorrect
        self.feedback = feedback
        self.explanation = explanation
    }
}

/// A Socratic hint from the buddy
public struct AIHint: Codable {
    public let hintText: String
    public let hintLevel: Int          // 1-4 (progressively more specific)

    public init(hintText: String, hintLevel: Int) {
        self.hintText = hintText
        self.hintLevel = hintLevel
    }
}

/// AI-generated buddy dialogue
public struct AIBuddyDialogue: Codable {
    public let dialogue: String
    public let emotion: String         // "happy", "thinking", "excited", "encouraging"

    public init(dialogue: String, emotion: String) {
        self.dialogue = dialogue
        self.emotion = emotion
    }
}

// MARK: - AI Service Protocol

/// Abstract interface for all AI operations.
/// Each provider (Apple Intelligence, OpenAI, Anthropic) implements this protocol.
public protocol AIServiceProtocol {
    /// The provider type
    var provider: AIProvider { get }

    /// Whether the service is currently available and configured
    var isAvailable: Bool { get }

    /// Generate a multiple-choice question
    func generateQuestion(
        subject: String,
        topic: String?,
        gradeLevel: Int,
        difficulty: Int
    ) async throws -> AIGeneratedQuestion

    /// Grade a student's short answer
    func gradeAnswer(
        question: String,
        correctAnswer: String,
        studentAnswer: String,
        subject: String
    ) async throws -> AIGradingResult

    /// Generate a Socratic hint (without giving away the answer)
    func generateHint(
        question: String,
        options: [String],
        correctIndex: Int,
        hintLevel: Int,
        buddyName: String,
        buddyPersonality: String
    ) async throws -> AIHint

    /// Generate contextual buddy dialogue
    func generateBuddyDialogue(
        buddyName: String,
        buddyPersonality: String,
        context: BuddyDialogueContext
    ) async throws -> AIBuddyDialogue
}

/// Context for buddy dialogue generation
public struct BuddyDialogueContext: Codable {
    public let trigger: String         // "correct_answer", "wrong_answer", "zone_enter", "idle", "level_up"
    public let zoneName: String?
    public let playerLevel: Int
    public let recentPerformance: String?  // "great", "struggling", "improving"
    public let additionalContext: String?

    public init(trigger: String, zoneName: String? = nil, playerLevel: Int = 1,
                recentPerformance: String? = nil, additionalContext: String? = nil) {
        self.trigger = trigger
        self.zoneName = zoneName
        self.playerLevel = playerLevel
        self.recentPerformance = recentPerformance
        self.additionalContext = additionalContext
    }
}

// MARK: - AI Service Errors

public enum AIServiceError: Error, LocalizedError {
    case notConfigured
    case notAvailable(reason: String)
    case invalidAPIKey
    case rateLimited
    case networkError(Error)
    case parsingError(String)
    case timeout
    case contentFiltered
    case unknownError(String)

    public var errorDescription: String? {
        switch self {
        case .notConfigured: return "AI service is not configured"
        case .notAvailable(let reason): return "AI not available: \(reason)"
        case .invalidAPIKey: return "Invalid API key"
        case .rateLimited: return "Too many requests â€” please wait a moment"
        case .networkError(let error): return "Network error: \(error.localizedDescription)"
        case .parsingError(let detail): return "Failed to parse AI response: \(detail)"
        case .timeout: return "AI request timed out"
        case .contentFiltered: return "Response was filtered by content safety"
        case .unknownError(let msg): return msg
        }
    }
}
